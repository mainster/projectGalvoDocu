# Projektziel und Anforderungskatalog #

<h4 class="sphd"><span>Stand der Technik</span></h4>
Diskret implementierte Regler sind in vielen Anwendungsbereichen zu finden. Durch leistungsfähigere Mikrocontroller und Signalprozessoren ist es einfacher geworden, _quasi-kontinuierliche_ Systeme zu entwerfen. Aufgrund ihrer Flexibilität und einfachen Erweiterbarkeit, werden digitale Regler zunehmend einer analogen Ausführungen vorgezogen.

<h4 class="sphd"><span>Systemzweck</span></h4>
Als übergeordnetes Projektziel soll ein optisches Ablenksystem (2-Achsen → XY-Koordinaten) für eine Laserquelle (Laserpointer, sichtbares Spektrum) auf Basis industriell gefertigter Spiegelgalvanometer geplant, simuliert, entworfen, aufgebaut und verifiziert werden. Die __Modellbildung__ und __Simulation__ des Gesamtsystems soll als __Schwerpunktthema__ betrachtet und entsprechend ausgearbeitet werden.

<h4 class="sphd"><span>Systemfunktion im Detail</span></h4>
Die detaillierte Beschreibung der Systemfunktionen wird untergliedert. Der Prototyp-Aufbau wird als __physisches System__ bezeichnet während im Abschnitt __Simulationsumgebung__ das Computermopdell des Gesamtsystems (MATLAB, Simulink, LTspice) näher beschrieben wird.

<h4 class="sp"><span>Physisches System</span></h4><figure class="floatr topal" style="width:185px"><img src="./pics/camb_6860_large_mirrors_sml_dim.png" title="Cambridge Technologies Galvanometer Modell 6860"><figcaption>Cambridge Technologies Galvanometer Modell 6860</figcaption></figure> Die beiden <lkey>[Moving-magnet Galvanometer](#klassifizierung)</lkey> der Firma [Cambridge Technologies](http://www.cambridgetechnology.com), bilden das Herzstück des Laserscanner-Aufbaus. Durch die zeitlich versetzte Positionierung eines Laserstrahls entsprechend zweier Koordinaten-Punkte einer Ebene, entsteht eine sichtbare Linie, wenn das Anfahren der Punkte schnell genug erfolgt. <lkey>Ortsvektoren</lkey> im $\mathbb{R}^2$ eignen sich hervorragend zur Lokalisierung von Punkten in einer Ebene. Soll anhand zweier Koordinatenpaare eine Gerade $\,g\,$ durch die Punkten $\,A\,$ und $\,B\,$ abgeleitet und in Vektornotation $\vec{v}$ dargestellt werden, so gilt 

<lmjx>$ \eqlbl{ g:\;\;\;\vec{v}=\overrightarrow{A B} = \begin{pmatrix}B_x\\\B_y\end{pmatrix} - \begin{pmatrix}A_x\\\A_y\end{pmatrix} = \begin{pmatrix}B_x-A_x\\\B_y-A_y\end{pmatrix} }{eqDirVect3} $</lmjx>

Um einen Vektor $\vec s$ der Länge $\left| \vec s\right|$ anhand zweier Koordinatenpaare $P_0=(x_0\,|\,y_0)$ und $P_1=(x_1\,|\,y_1)$ an einer bestimmten Stelle zu beschreiben, bietet sich eine alternative Beschreibungsform für Geraden aus dem Teilgebiet der analytischen Geometrie an. In der Parameter- oder Punktrichtungsform wird ein Vektor $\vec s$ entlang einer Geraden $\,g\,$ beschrieben durch:

$$ g:\;\;\;\vec{s}=\vec p + \lambda\cdot\vec v\; $$

Durch die Linearkombination zweier XY-Tupel, dem Ortsvektor (resp. Stützvektor, Aufpunkt) $\;\vec p\;$ und dem Richtungsvektor $\;\vec v\;$, wird die Gerade $\,g\,$ eindeutig bezüglich eines Koordinaten&shy;ursprungs $\,0\,$ abgebildet. Aufgrund dieser Information lässt sich bereits eine Berechnungs&shy;vorschrift für die Implementierung auf dem Mikro&shy;controller formulieren (siehe Quellcodeausschnitt). Um die notwendigen Quelldaten automatisch erzeugen zu können, muss das System in der Lage sein, einfache <lkey>Vektorgrafiken</lkey> zu verarbeiten. Die Koordinaten zur Positionierung sowie das Signal zur Dunkel&shy;tastung des Laserstrahls, werden am PC über das SVG-Dateiformat (z. B. Inkscape) definiert und mittels XML-Parser ([_python Skript: svgCoord.py_](#xml-parser)) in eine C-Header-Datei exportiert.


<table class="noalter" style="border-spacing: 0px; margin: 0; padding: 0px;"><figure>
  <tr>
    <td><center><a href="https://www.gnu.org/graphics/nu-gnu.svg" target="_blank"><figure><img src="./pics/gnu_orig.svg" title="&quot;GNU-Kopf&quot; im SVG Format (www.gnu.org)" class="noborder" /><figcaption>Grafik im SVG Format (www.gnu.org)</figcaption></a></center></td>
    <td><center><a href="./pics/gnu_bezier.svg" target="_blank"><figure><img src="./pics/gnu_bezier.svg" title="&quot;GNU-Kopf&quot;&#13;Flächen und Gradienten entfernt&#13;Outline besteht aus Bezier-Kurven" class="noborder" /><figcaption>Flächen und Gradienten entfernt, Outline besteht aus Bezier-Kurven</figcaption></a></center></td>
  </tr>
  <tr>
    <td><center><a href="./pics/gnu_flatten_lowres.svg" target="_blank"><figure><img src="./pics/gnu_flatten_lowres.svg" title="&quot;GNU-Kopf&quot;&#13;Bezier-Kurven auf lineare Splines reduziert&#13;Inkscape: Extensions => Modify Path => Flatten Bezier..." class="noborder" /><figcaption>Bezier-Kurven auf lineare Splines reduziert, Inkscape: Extensions => Modify Path => Flatten Bezier...</figcaption></a></center></td>
    <td><center><a href="./pics/gnu_flatten_lowres_mod.svg" target="_blank"><figure><img src="./pics/gnu_flatten_lowres_mod.svg" title="GNU Outline, visualisierte Knotenpunkte" class="noborder" /><figcaption>Visualisierte Knotenpunkte</figcaption></a></center></td>
  </tr><figcaption><center><b><em>GNU Kopf</b> als skalierbare Vektorgrafik</em></center></figcaption></figure>
</table>
<br>

Gegenüber Rastergrafiken (Pixelgrafik, "Punkt-für-Punk") besitzen Vektorgrafiken den großen Vorteil, dass eine Transformation denkbar einfach durchgeführt werden kann. Soll zum Beispiel die letzte Abbildung _(Visualisierte Knotenpunkte)_ skaliert werden, genügt eine triviale Skalarmultiplikation der Abbildungsmatrix mit einem Skalierungsfaktor $\;\lambda\;$. Genau so einfach kann eine Transformation mittels Drehmatrix $\,M_{Rot}\,$ abgebildet werden. 

$$ \eqlbl{ M_{Rot}(x)=\begin{pmatrix}cos(x) & -sin(x) \\\sin(x) & cos(x) \end{pmatrix}}{eqRotMatrix} $$


```c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <fcntl.h>
#include <math.h>

/**
 * GCC compiler flag
 */
#pragma GCC diagnostic ignored "-Wwrite-strings"

/**
 * Typedef line segement.
 * A line segment contains two nodes (x1,y1),(x2,y2) 
 */
typedef float lseg_t[4];      

const lseg_t gnu[ ] = {
  {  0.1624,  0.0612,  0.1624,  0.0612 },
  {  0.1624,  0.0612,  0.1689,  0.0649 },
  {  0.1689,  0.0649,  0.1718,  0.0571 },
  {  0.1718,  0.0571,  0.1650,  0.0541 },
  {  0.1650,  0.0541,  0.1624,  0.0612 },
  { -0.0150,  0.0578, -0.0150,  0.0578 },
  { -0.0150,  0.0578, -0.0083,  0.0572 },
  { -0.0083,  0.0572, -0.0100,  0.0498 },
  { -0.0100,  0.0498, -0.0167,  0.0511 },
  { -0.0167,  0.0511, -0.0150,  0.0578 },
  {  0.0642, -0.3263,  0.1553, -0.3317 },
  {  0.1553, -0.3317,  0.2345, -0.3155 },
  {  0.0987, -0.3861,  0.1005, -0.4032 },
  {  0.0091, -0.3907,  0.0077, -0.4159 },
  {  0.1986,  0.0467,  0.1795,  0.0397 },
  {  0.1795,  0.0397,  0.1570,  0.0418 },
  {  0.1896,  0.1019,  0.1577,  0.1116 },
  {  0.1577,  0.1116,  0.1335,  0.1015 },
  {  0.0184,  0.0952, -0.0232,  0.1155 },
  { -0.0232,  0.1155, -0.0590,  0.0821 },
  { -0.0107,  0.0698, -0.0107,  0.0698 },
  { -0.0107,  0.0698,  0.0086,  0.0573 },
  {  0.0086,  0.0573, -0.0084,  0.0380 },
  { -0.0084,  0.0380, -0.0265,  0.0524 },
  { -0.0265,  0.0524, -0.0107,  0.0698 },
  {  0.0228,  0.0536, -0.0053,  0.0342 },
  { -0.0053,  0.0342, -0.0542,  0.0478 },
  {  0.0261,  0.0671,  0.0261,  0.0671 },
  {  0.0261,  0.0671, -0.0193,  0.0690 },
  { -0.0193,  0.0690, -0.0653,  0.0487 },
  { -0.0653,  0.0487, -0.0358,  0.0778 },
  { -0.0358,  0.0778,  0.0160,  0.0860 },
  {  0.0160,  0.0860,  0.0261,  0.0671 },
  {  0.1716,  0.0736,  0.1716,  0.0736 },
  {  0.1716,  0.0736,  0.1844,  0.0579 },
  {  0.1844,  0.0579,  0.1678,  0.0433 },
  {  0.1678,  0.0433,  0.1524,  0.0620 },
  {  0.1524,  0.0620,  0.1716,  0.0736 },
  {  0.1408,  0.0763,  0.1408,  0.0763 },
  {  0.1408,  0.0763,  0.1805,  0.0729 },
  {  0.1805,  0.0729,  0.2013,  0.0574 },
  {  0.2013,  0.0574,  0.2066,  0.0700 },
  {  0.2066,  0.0700,  0.1742,  0.0860 },
  {  0.1742,  0.0860,  0.1408,  0.0763 },
  {  0.1969,  0.0942,  0.1969,  0.0797 },
  {  0.2125, -0.0169,  0.1969,  0.0274 },
  {  0.1921,  0.0932,  0.1960,  0.1455 },
  {  0.1960,  0.1455,  0.1708,  0.1745 },
  {  0.0610,  0.0826,  0.0257,  0.1532 },
  {  0.0524, -0.4105,  0.0659, -0.4554 },
  {  0.0659, -0.4554,  0.1005, -0.4030 },
  {  0.1005, -0.4030,  0.1180, -0.4504 },
  {  0.1180, -0.4504,  0.1826, -0.3773 },
  {  0.1826, -0.3773,  0.2418, -0.3053 },
  {  0.2418, -0.3053,  0.2493, -0.2417 },
  { -0.0411, -0.1893, -0.0007, -0.2361 },
  { -0.0007, -0.2361,  0.0503, -0.2507 },
  {  0.0503, -0.2507,  0.1389, -0.2444 },
  {  0.1389, -0.2444,  0.2211, -0.2532 },
  {  0.2211, -0.2532,  0.2443, -0.2445 },
  {  0.2443, -0.2445,  0.2617, -0.2164 },
  {  0.2617, -0.2164,  0.2595, -0.1779 },
  {  0.2595, -0.1779,  0.2763, -0.1332 },
  {  0.2763, -0.1332,  0.2835, -0.1003 },
  {  0.2835, -0.1003,  0.2714, -0.0652 },
  {  0.2714, -0.0652,  0.2366, -0.0683 },
  {  0.2366, -0.0683,  0.2008, -0.0335 },
  {  0.2008, -0.0335,  0.1321,  0.0860 },
  {  0.1321,  0.0860,  0.1592,  0.1532 },
  {  0.0671, -0.0829,  0.0671, -0.0829 },
  {  0.0671, -0.0829,  0.0671, -0.1075 },
  {  0.0671, -0.1075,  0.0992, -0.1216 },
  {  0.0992, -0.1216,  0.1234, -0.1336 },
  {  0.1234, -0.1336,  0.1095, -0.0949 },
  {  0.1095, -0.0949,  0.0671, -0.0829 },
  {  0.0334, -0.1177,  0.0271, -0.0816 },
  {  0.0271, -0.0816,  0.0383, -0.0586 },
  {  0.0383, -0.0586,  0.0702, -0.0442 },
  {  0.0702, -0.0442,  0.1244, -0.0597 },
  {  0.1244, -0.0597,  0.1562, -0.1035 },
  {  0.2120, -0.0539,  0.2134, -0.0325 },
  {  0.2134, -0.0325,  0.2114,  0.0129 },
  {  0.2114,  0.0129,  0.2488, -0.0251 },
  {  0.2488, -0.0251,  0.3101, -0.0456 },
  {  0.3101, -0.0456,  0.3576, -0.0410 },
  {  0.3576, -0.0410,  0.3817, -0.0132 },
  {  0.3817, -0.0132,  0.3552, -0.0100 },
  {  0.3552, -0.0100,  0.3367,  0.0103 },
  {  0.3367,  0.0103,  0.3194,  0.0516 },
  { -0.0595,  0.1532, -0.1117,  0.1319 },
  { -0.1117,  0.1319, -0.1383,  0.0463 },
  { -0.1383,  0.0463, -0.1795, -0.0538 },
  { -0.1795, -0.0538, -0.2925, -0.1128 },
  { -0.2925, -0.1128, -0.3827, -0.1409 },
  { -0.3827, -0.1409, -0.3381, -0.0809 },
  { -0.3381, -0.0809, -0.3055,  0.0051 },
  { -0.2460,  0.1262, -0.2460,  0.1262 },
  { -0.2460,  0.1262, -0.2923,  0.0527 },
  { -0.2923,  0.0527, -0.3052,  0.0062 },
  { -0.3052,  0.0062, -0.3261,  0.0052 },
  { -0.3261,  0.0052, -0.4020,  0.0332 },
  { -0.4020,  0.0332, -0.4473,  0.0732 },
  { -0.4473,  0.0732, -0.4753,  0.1278 },
  { -0.4753,  0.1278, -0.4949,  0.2384 },
  { -0.4949,  0.2384, -0.4402,  0.3583 },
  { -0.4402,  0.3583, -0.3784,  0.4158 },
  { -0.3784,  0.4158, -0.3014,  0.4493 },
  { -0.3014,  0.4493, -0.1912,  0.4383 },
  { -0.1912,  0.4383, -0.1287,  0.4095 },
  { -0.1287,  0.4095, -0.0788,  0.4125 },
  { -0.0788,  0.4125, -0.1214,  0.3777 },
  { -0.1214,  0.3777, -0.2685,  0.3758 },
  { -0.2685,  0.3758, -0.3203,  0.3546 },
  { -0.3203,  0.3546, -0.3548,  0.3078 },
  { -0.3548,  0.3078, -0.3788,  0.2210 },
  { -0.3788,  0.2210, -0.3654,  0.1748 },
  { -0.3654,  0.1748, -0.3269,  0.1495 },
  { -0.3269,  0.1495, -0.2696,  0.1763 },
  { -0.2696,  0.1763, -0.2114,  0.2344 },
  { -0.2114,  0.2344, -0.1498,  0.2936 },
  { -0.1498,  0.2936, -0.0827,  0.3235 },
  { -0.0827,  0.3235, -0.0219,  0.3016 },
  { -0.0219,  0.3016,  0.0306,  0.2798 },
  {  0.0306,  0.2798,  0.0693,  0.2993 },
  {  0.0693,  0.2993,  0.1263,  0.3177 },
  {  0.1263,  0.3177,  0.1859,  0.2973 },
  {  0.1859,  0.2973,  0.2308,  0.2461 },
  {  0.2308,  0.2461,  0.2797,  0.1870 },
  {  0.2797,  0.1870,  0.3372,  0.1610 },
  {  0.3372,  0.1610,  0.3640,  0.1728 },
  {  0.3640,  0.1728,  0.3895,  0.2229 },
  {  0.3895,  0.2229,  0.3781,  0.3027 },
  {  0.3781,  0.3027,  0.3450,  0.3564 },
  {  0.3450,  0.3564,  0.2134,  0.3777 },
  {  0.2134,  0.3777,  0.1904,  0.3980 },
  {  0.1904,  0.3980,  0.1863,  0.4125 },
  {  0.1863,  0.4125,  0.2327,  0.4087 },
  {  0.2327,  0.4087,  0.3488,  0.4474 },
  {  0.3488,  0.4474,  0.4250,  0.4280 },
  {  0.4250,  0.4280,  0.4765,  0.3738 },
  {  0.4765,  0.3738,  0.5000,  0.2964 },
  {  0.5000,  0.2964,  0.4959,  0.1842 },
  {  0.4959,  0.1842,  0.4512,  0.0988 },
  {  0.4512,  0.0988,  0.3926,  0.0601 },
  {  0.3926,  0.0601,  0.3198,  0.0507 },
  {  0.3198,  0.0507,  0.2540,  0.1532 },
  {  0.2540,  0.1532,  0.1880,  0.1963 },
  {  0.1880,  0.1963,  0.1089,  0.1900 },
  {  0.1089,  0.1900,  0.0334,  0.2074 },
  {  0.0334,  0.2074, -0.0469,  0.1881 },
  { -0.0469,  0.1881, -0.1138,  0.2013 },
  { -0.1138,  0.2013, -0.2460,  0.1262 },
  { -0.1862, -0.1825, -0.1190, -0.3383 },
  { -0.1190, -0.3383, -0.0598, -0.4160 },
  { -0.0598, -0.4160, -0.0129, -0.4497 },
  { -0.0129, -0.4497,  0.0076, -0.4164 },
  {  0.0076, -0.4164,  0.0262, -0.4490 },
  {  0.0262, -0.4490,  0.0570, -0.3895 }
};


const lseg_t *pGnu = &gnu[0];
lseg_t *pGnuTrans;

/**
 * @brief      Export matrix to MATLAB resource, M=load('gnu.mat', '-ASCII')
 * @param      pI         Pointer to input matrix.
 * @param[in]  nRows      Row count of input matrix.
 * @param      filePath   The file path to MATLAB resource.
 */
int matrixExport(const lseg_t *pI, uint16_t nRows, char *filePath) {
  FILE *fd = fopen(filePath, "w");
  if (fd == NULL) {
    printf("Error opening file!\n");
    return -1;
  }

  for (uint16_t line = 0; line < nRows; line++) {
    fprintf(fd, "% 6.4f\t% 6.4f\t% 6.4f\t% 6.4f\n",
            (*pI)[0], (*pI)[1], (*pI)[2], (*pI)[3]);
    pI++;
  }

  fclose(fd);
  return 0;
}


/**
 * @brief      Rotate a given [N][4] matrix by angle radians.
 * @param      pI      Pointer to input matrix.
 * @param      pO      Pointer to rotated matrix
 * @param[in]  nRows   Row count of input matrix.
 * @param[in]  angle   Rotation angle [rad].
 * @param[in]  scale   Optional argument
 */
int matrixTransform(const lseg_t *pI, lseg_t *pO, uint16_t nRows, double angle, double scale = -1) {
  for (uint16_t line = 0; line < nRows; line++) {
    if (scale > 0) {
      /* Scale start node (x_start, y_start) */
      (*pO)[0] = (*pI)[0]*scale;
      (*pO)[1] = (*pI)[1]*scale;

      /* Scale end node (x_end, y_end) */
      (*pO)[2] = (*pI)[2]*scale;
      (*pO)[3] = (*pI)[3]*scale;

      if (! line) printf("Scale by %f\n", scale);
    }
    else { 
      /* Transform start node (x_start, y_start) */
      (*pO)[0] = (*pI)[0]*cos(angle) + (*pI)[1]*sin(angle);
      (*pO)[1] = (*pI)[1]*cos(angle) - (*pI)[0]*sin(angle);

      /* Transform end node (x_end, y_end) */
      (*pO)[2] = (*pI)[2]*cos(angle) + (*pI)[3]*sin(angle);
      (*pO)[3] = (*pI)[3]*cos(angle) - (*pI)[2]*sin(angle);

      if (! line) printf("Rotate by %f\n", angle);
    }
    pI++; 
    pO++;
  }

  return 0;
}

/**
 * @brief      Main function.
 */
int main (void) {
  /* Calculate number of rows, i.e. number of line segments. */
  int nRows = sizeof(gnu)/sizeof(gnu[0]);

  /* maclloc clean memory portion for output matrix. */
  pGnuTrans = (lseg_t *) calloc(nRows, sizeof(lseg_t));

  /* Export unmodified matrix as MATLAB resource */
  matrixExport(pGnu, nRows, "gnu.mat");

  /* Rotate matrix by 45° and export. */
  matrixTransform(pGnu, pGnuTrans, nRows, M_PI/4);
  matrixExport(pGnuTrans, nRows, "gnuRot.mat");

  /* Scale matrix to 75% and export. */
  matrixTransform(pGnu, pGnuTrans, nRows, 0, .75);
  matrixExport(pGnuTrans, nRows, "gnuScal.mat");

  free(pGnuTrans);
  return 0;
}

```

<div style="display: inline;">
Die später eingesetzte <lkey>Laserquelle</lkey> sollte für Dauerbetrieb ausgelegt sein. Die Halbleiter-Diode eines batteriebetriebenen Standard-Laserpointers, eignet sich meist nur für den Impulsbetrieb.<a href="./pics/galvoMirrorsXY_1.svg" target="_blank"><figure class="floatr" style="height: 185px;"><img style="display: inline-block;" src="./pics/galvoMirrorsXY_1.svg" title="Funktionsprinzip XY-Scanner" align="bottom" class="noborder"><figcaption>Funktionsprinzip XY-Scanner</figcaption></figure></a> Thermisch bedingt, geht die wahrgenommene Intensität des Laserlichts bereits nach einigen Sekunden zurück. Selbst Handlaserpointer mit geregelter Ausgangsleistung, driften aufgrund der thermisch instabilen Monitordiode, sobald die Betriebstemperatur des Laserchips über die Auslegungsgrenze hinaus, ansteigt. Durch den Betrieb eines semiprofessionellen Lasermoduls (Laserklasse 3B, 532nm (Grün), max. 50mW, 25€) bei ca. 10% Ausgangsleistung, soll eine Laserquelle mit 100% Einschaltdauer bereit gestellt werden.
</div>

<h4 class="sp"><span>Simulationsumgebung</span></h4>Bereits bei niedrigen Systemordnungen ist es von Vorteil, wenn Reglerparameter anhand eines Computermodells optimiert und die Stabilität eines parametrierten Regelkreises quantitativ ermittelt werden können. Der grundlegende Modellbildungs<u style="font-weight: bold">prozess</u> eines Gesamtsystems mit zeit-diskreter Regelung, unterscheidet sich nicht signifikant vom Modellbildungsprozess bei kontinuierlicher, sprich analoger Regelung. In der klassischen Regelungstechnik werden die Teilsysteme eines Regelkreises in lineare, __zeitinvariante__ Systeme überführt welche dann als LTI-Blöcke dargestellt werden können. 

<boxed>Die Forderung nach Zeitinvarianz impliziert immer auch __Rückwirkungsfreiheit__ zwischen den Teilsystemen.</boxed> 

Infolge dessen ist es gleichgültig, ob einer oder gar mehrere Blöcke in zeit-diskreter Form Formuliert werden - solange alle notwendigen LTI-Bedingungen erfüllt sind.

Aus dem Modellzweck oder Kontext wird die notwendige [_Modellgranularität_](#modell) abgeleitet. Nach Nyquist ist, im Falle einer zeitdiskreten Regelung, ein Antialiasing Filter in den Signalpfad vor den ADC zu platzieren. Um aus den diskret berechneten, gewichteten Impulsfolgen, nach der DAC-Wandlung wieder ein analoges Stellsignal zu erhalten, werden _Rekonstruktionsfilter_ zur Entzerrung des Quantisierungsfehlers eingesetzt. Bei Simulationen bezüglich Systemdynamik oder zur Stabilitätsberechnung, dürfen die zusätzlichen Filterpole meist nicht ignoriert werden. Somit sind die Teilsysteme "Antialiasing-" und "Rekonstruktionsfilter" in das Computermodell des Gesamtsystems zu integrieren.
Entsprechendes gilt auch für die Modellierung weiterer Teilsysteme wie z. B. dem Stellglied sowie Messumformer + Tiefpassfilterung.

Design
Systemeinsatz
<h4 class="specs"><span>Allgemeine Anforderungen</span></h4>
Safety!

Quality --> testbild resol

- safe state guard
- exceptions

<h4 class="specs"><span>Systemanforderungen</span></h4>

<div class="spaced" markdown=1>
0. Bei den Aktoren handelt es sich um Spiegelgalvanometer der Firma Cambridge Technologies (Modell 6860). Diese sind im Sinne der _Baugruppen-Wahl_  als gegeben zu betrachten (vergl. _Bestandsbaugruppe_).
1. Die Positionsregelung der Spiegelachsen soll diskret realisiert und nach erfolgreicher Simulation auf einem Mikrocontroller [_STM32F429i_][@STM32F429i] implementiert werden.
2. Die Sollwerte der Aufpunkt-Koordinaten werden als dreiwertige Tupel [X-Pos, Y-Pos, Laser-Blanking] im Speicher des Mikrocontrollers abgelegt und müssen über eine PC-Schnittstelle aktualisiert werden können.
3. Die Positionierung des Laserpunktes soll hinreichend "schnell" und "präzise" erfolgen so dass sich zumindest einfache geometrische Figuren auf einen weißen Hintergrund projizieren lassen.
4. Das System soll auf ein Computermodell abgebildet werden so dass unterschiedliche Regelalgorithmen evaluiert werden können. Außerdem sollen Hardware-Anpassungen der Signalkonditionierung (primär Antialiasing-/Rekonstruktionsfilter) mit minimalem Aufwand in die Simulation des Gesamtsystems einzupflegen sein.
5. Die Prototyp-Hardware soll bereits alle notwendigen Komponenten umfassen, die zur Messung weiterer Zustandsgrößen der Regelstrecke notwendig sind. Somit kann der Aufbau als Grundlage für spätere Tests einer Zustandsraum-Regelung (state space model) genutzt werden.
6. Die Anforderung an den Fertigungsprozess der Prototyp-Hardware sollte entsprechend den Möglichkeiten vor Ort (HsKA: PCB-Fräse, manuelle Durchkontaktierung bei doppelseitigen Layouts) angepasst werden.
</div>

</par>

Zu Beginn des Kapitels [Modellbildungsprozess](#modellbildungsprozess) folgt eine erste Aufteilung des Projekts.


<!-- wird $\vec v$ als  Richtungsvektor von $\vec{g}$.
Zur mathematischen Beschreibung dieser (abschnittsweise definierten) Geraden, kann aus zwei aufeinander folgenden XY-Tupel eine Geradengleichung abgeleitet werden. Um 

Aus der Koordinatenform einer Geradengleichung mit den Parametern  ${a}, {b}$ und ${c}$ ist ein Normalenvektor der Gerade direkt als $\vec n=(a,b)^{T}$ ablesbar und damit ein Richtungsvektor der Geraden analog zur Normalenform über   

$$ {\vec {u}}={\begin{pmatrix}-b\\\a\end{pmatrix}} $$ ermitteln. Einen Stützvektor der Geraden erhält man, je nachdem ob $a$ oder $b$ ungleich null ist, durch Wahl von
<center>$ {\vec {p}}={\begin{pmatrix}c/a\\\0\end{pmatrix}}\;\;\; $ oder $ \;\;\;{\vec {p}}={\begin{pmatrix}0\\\c/b\end{pmatrix}} $.</center> -->
