# Projektziel und Anforderungskatalog #

<h4 class="sphd"><span>Stand der Technik</span></h4>
Diskret implementierte Regler sind in vielen Anwendungsbereichen zu finden. Durch leistungsfähigere Mikrocontroller und Signalprozessoren ist es einfacher geworden, _quasi-kontinuierliche_ Systeme zu entwerfen. Aufgrund ihrer Flexibilität und einfachen Erweiterbarkeit, werden digitale Regler zunehmend einer analogen Ausführungen vorgezogen.

<h4 class="sphd"><span>Systemzweck</span></h4>
Als übergeordnetes Projektziel soll ein optisches Ablenksystem (2-Achsen → XY-Koordinaten) für eine Laserquelle (Laserpointer, sichtbares Spektrum) auf Basis industriell gefertigter Spiegelgalvanometer geplant, simuliert, entworfen, aufgebaut und verifiziert werden. Die __Modellbildung__ und __Simulation__ des Gesamtsystems soll als __Schwerpunktthema__ betrachtet und entsprechend ausgearbeitet werden.

<h4 class="sphd"><span>Systemfunktion im Detail</span></h4>
Die detaillierte Beschreibung der Systemfunktionen wird untergliedert. Der Prototyp-Aufbau wird als __physisches System__ bezeichnet während im Abschnitt __Simulationsumgebung__ das Computermopdell des Gesamtsystems (MATLAB, Simulink, LTspice) näher beschrieben wird.

<h4 class="sp"><span>Physisches System</span></h4><figure class="floatr topal" style="width:185px"><img src="./pics/camb_6860_large_mirrors_sml_dim.png" title="Cambridge Technologies Galvanometer Modell 6860"><figcaption>Cambridge Technologies Galvanometer Modell 6860</figcaption></figure> Die beiden <lkey>[Moving-magnet Galvanometer](#klassifizierung)</lkey> der Firma [Cambridge Technologies](http://www.cambridgetechnology.com), bilden das Herzstück des Laserscanner-Aufbaus. Durch die zeitlich versetzte Positionierung eines Laserstrahls entsprechend zweier Koordinaten-Punkte einer Ebene, entsteht eine sichtbare Linie, wenn das Anfahren der Punkte schnell genug erfolgt. <lkey>Ortsvektoren</lkey> im $\mathbb{R}^2$ eignen sich hervorragend zur Lokalisierung von Punkten in einer Ebene. Soll anhand zweier Koordinatenpaare eine Gerade $\,g\,$ durch die Punkten $\,A\,$ und $\,B\,$ abgeleitet und in Vektornotation $\vec{v}$ dargestellt werden, so gilt 

<lmjx>$ \eqlbl{ g:\;\;\;\vec{v}=\overrightarrow{A B} = \begin{pmatrix}B_x\\\B_y\end{pmatrix} - \begin{pmatrix}A_x\\\A_y\end{pmatrix} = \begin{pmatrix}B_x-A_x\\\B_y-A_y\end{pmatrix} }{eqDirVect3} $</lmjx>

Um einen Vektor $\vec s$ der Länge $\left| \vec s\right|$ anhand zweier Koordinatenpaare $P_0=(x_0\,|\,y_0)$ und $P_1=(x_1\,|\,y_1)$ an einer bestimmten Stelle zu beschreiben, bietet sich eine alternative Beschreibungsform für Geraden aus dem Teilgebiet der analytischen Geometrie an. In der Parameter- oder Punktrichtungsform wird ein Vektor $\vec s$ entlang einer Geraden $\,g\,$ beschrieben durch:

$$ g:\;\;\;\vec{s}=\vec p + \lambda\cdot\vec v\; $$

Durch die Linearkombination zweier XY-Tupel, dem Ortsvektor (resp. Stützvektor, Aufpunkt) $\;\vec p\;$ und dem Richtungsvektor $\;\vec v\;$, wird die Gerade $\,g\,$ eindeutig bezüglich eines Koordinatenursprungs $\,0\,$ abgebildet. Aufgrund dieser Information lässt sich bereits eine Berechnungsvorschrift für die Implementierung auf dem Mikrocontroller formulieren (siehe Quellcodeausschnitt). Um die notwendigen Quelldaten automatisch erzeugen zu können, muss das System in der Lage sein, einfache <lkey>Vektorgrafiken</lkey> zu verarbeiten. Die Koordinaten zur Positionierung sowie das Signal zur Dunkeltastung des Laserstrahls, werden am PC über das SVG-Dateiformat (z. B. Inkscape) definiert und mittels XML-Parser [_python Skript: svgCoord.py_](#xml-parser)) in eine C-Header-Datei exportiert.

```c
#include <stdio.h>
#include <stdint.h>

typedef float node_t[2];      /* A nodes X- and Y- values */
typedef node_t lseg_t[2];     /* A line segment is defined by 2 nodes (x1,y1),(x2,y2) */
typedef lseg_t svg_t[ ];      

svg_t Gnu[ ][2] = {
   { 0.55703, 0.88948, 0.52622, 0.94901 },
   { 0.52622, 0.94901, 0.50761, 0.91644 },
   { 0.50761, 0.91644, 0.48707, 0.94969 }   
}

const svg_t gnu = {
    { 0.55703, 0.88948, 0.52622, 0.94901 },
    { 0.52622, 0.94901, 0.50761, 0.91644 },
    { 0.50761, 0.91644, 0.48707, 0.94969 },
    { 0.48707, 0.94969, 0.44022, 0.91600 },
    { 0.44022, 0.91600, 0.38105, 0.83828 },
    { 0.38105, 0.83828, 0.31376, 0.68246 },
    { 0.25401, 0.37375, 0.38618, 0.29869 },
    { 0.38618, 0.29869, 0.45309, 0.31194 },
    { 0.45309, 0.31194, 0.53340, 0.29259 },
    { 0.53340, 0.29259, 0.60887, 0.31001 },
    { 0.60887, 0.31001, 0.68796, 0.30372 }
};


int main () {
   for (uint8_t line = 0; line < sizeof(gnu)/sizeof(gnu[0]); line++) {
      printf("Seg %i:\t%5.3g\t%5.3g\t%5.3g\t%5.3g\n", 
             line, gnu[line][0], gnu[line][1], gnu[line][2], gnu[line][3]);
   }
   
   return 0;
}
```

Gegenüber Rastergrafiken (Pixelgrafik, "Punkt-für-Punk") besitzen Vektorgrafiken den großen Vorteil, dass eine Transformation denkbar einfach durchgeführt werden kann. Soll zum Beispiel nachfolgende Abbildung skaliert werden, genügt eine triviale Skalarmultiplikation der Abbildungsmatrix mit einem Skalierungsfaktor $\;\lambda\;$. 


<table class="noalter" style="border-spacing: 0px; margin: 0; padding: 0px;"><figure>
  <tr>
    <td><center><a href="https://www.gnu.org/graphics/nu-gnu.svg" target="_blank"><figure><img src="./pics/gnu_orig.svg" title="&quot;GNU-Kopf&quot; im SVG Format (www.gnu.org)" class="noborder" /><figcaption>Grafik im SVG Format (www.gnu.org)</figcaption></a></center></td>
    <td><center><a href="./pics/gnu_bezier.svg" target="_blank"><figure><img src="./pics/gnu_bezier.svg" title="&quot;GNU-Kopf&quot;&#13;Flächen und Gradienten entfernt&#13;Outline besteht aus Bezier-Kurven" class="noborder" /><figcaption>Flächen und Gradienten entfernt, Outline besteht aus Bezier-Kurven</figcaption></a></center></td>
  </tr>
  <tr>
    <td><center><a href="./pics/gnu_flatten_lowres.svg" target="_blank"><figure><img src="./pics/gnu_flatten_lowres.svg" title="&quot;GNU-Kopf&quot;&#13;Bezier-Kurven auf lineare Splines reduziert&#13;Inkscape: Extensions => Modify Path => Flatten Bezier..." class="noborder" /><figcaption>Bezier-Kurven auf lineare Splines reduziert, Inkscape: Extensions => Modify Path => Flatten Bezier...</figcaption></a></center></td>
    <td><center><a href="./pics/gnu_flatten_lowres_mod.svg" target="_blank"><figure><img src="./pics/gnu_flatten_lowres_mod.svg" title="GNU Outline, visualisierte Knotenpunkte" class="noborder" /><figcaption>Visualisierte Knotenpunkte</figcaption></a></center></td>
  </tr><figcaption><center><b><em>GNU Kopf</b> als skalierbare Vektorgrafik</em></center></figcaption></figure>
</table>
<br>

<!-- 
<a href="https://www.gnu.org/graphics/nu-gnu.svg"><img src="./pics/gnu_untouched.svg" title="The GNU" align="left" width="50%"/></a><a href="./pics/gnu_beziers.svg" target="_blank"><img src="./pics/gnu_beziers.svg" title="GNU Outline, Bezier Pfade" align="right" width="50%"/></a>
<a href="./pics/gnu_flatten_lowres.svg" target="_blank"><img src="./pics/gnu_flatten_lowres.svg" title="GNU Outline, reduziert auf Linien-Segmente" align="top" width="50%"/></a><a href="./pics/gnu_mod.svg" target="_blank"><img src="./pics/gnu_mod.svg" title="GNU Outline, visualisierte Knotenpunkte" align="right" width="50%"/></a> -->

Die später eingesetzte <lkey>Laserquelle</lkey> sollte für Dauerbetrieb ausgelegt sein. Die Halbleiter-Diode eines batteriebetriebenen Standard-Laserpointers, eignet sich meist nur für den Impulsbetrieb. <a href="./pics/galvoMirrorsXY_1.svg" target="_blank"><img src="./pics/galvoMirrorsXY_1.svg" title="Funktionsprinzip XY-Scanner" align="bottom" height="185px" style="float:right; margin: 0.2em 0em 0em 1em;"/></a>Thermisch bedingt, geht die wahrgenommene Intensität des Laserlichts bereits nach einigen Sekunden zurück. Selbst Handlaserpointer mit geregelter Ausgangsleistung, driften aufgrund der thermisch instabilen Monitordiode, sobald die Betriebstemperatur des Laserchips über die Auslegungsgrenze hinaus, ansteigt. Durch den Betrieb eines semiprofessionellen Lasermoduls (Laserklasse 3B, 532nm (Grün), max. 50mW, 25€) bei ca. 10% Ausgangsleistung, soll eine Laserquelle mit 100% Einschaltdauer bereit gestellt werden.

<h4 class="sp"><span>Simulationsumgebung</span></h4>Bereits bei niedrigen Systemordnungen ist es von Vorteil, wenn Reglerparameter anhand eines Computermodells optimiert und die Stabilität eines parametrierten Regelkreises quantitativ ermittelt werden können. Der grundlegende Modellbildungs<u style="font-weight: bold">prozess</u> eines Gesamtsystems mit zeit-diskreter Regelung, unterscheidet sich nicht signifikant vom Modellbildungsprozess bei kontinuierlicher, sprich analoger Regelung. In der klassischen Regelungstechnik werden die Teilsysteme eines Regelkreises in lineare, __zeitinvariante__ Systeme überführt welche dann als LTI-Blöcke dargestellt werden können. 

<boxed>Die Forderung nach Zeitinvarianz impliziert immer auch __Rückwirkungsfreiheit__ zwischen den Teilsystemen.</boxed> 

Infolge dessen ist es gleichgültig, ob einer oder gar mehrere Blöcke in zeit-diskreter Form Formuliert werden - solange alle notwendigen LTI-Bedingungen erfüllt sind.

Aus dem Modellzweck oder Kontext wird die notwendige [_Modellgranularität_](#modell) abgeleitet. Nach Nyquist ist, im Falle einer zeitdiskreten Regelung, ein Antialiasing Filter in den Signalpfad vor den ADC zu platzieren. Um aus den diskret berechneten, gewichteten Impulsfolgen, nach der DAC-Wandlung wieder ein analoges Stellsignal zu erhalten, werden _Rekonstruktionsfilter_ zur Entzerrung des Quantisierungsfehlers eingesetzt. Bei Simulationen bezüglich Systemdynamik oder zur Stabilitätsberechnung, dürfen die zusätzlichen Filterpole meist nicht ignoriert werden. Somit sind die Teilsysteme "Antialiasing-" und "Rekonstruktionsfilter" in das Computermodell des Gesamtsystems zu integrieren.

Entsprechend sind auch Modelle für das Stellglied und den Messumformer + Tiefpass zu erstellen.   

Design
Systemeinsatz
<h4 class="specs"><span>Allgemeine Anforderungen</span></h4>
Safety!

Quality --> testbild resol

- safe state guard
- exceptions

<h4 class="specs"><span>Systemanforderungen</span></h4>

<div class="spaced" markdown=1>
0. Bei den Aktoren handelt es sich um Spiegelgalvanometer der Firma Cambridge Technologies (Modell 6860). Diese sind im Sinne der _Baugruppen-Wahl_  als gegeben zu betrachten (vergl. _Bestandsbaugruppe_).
1. Die Positionsregelung der Spiegelachsen soll diskret realisiert und nach erfolgreicher Simulation auf einem Mikrocontroller [_STM32F429i_][@STM32F429i] implementiert werden.
2. Die Sollwerte der Aufpunkt-Koordinaten werden als dreiwertige Tupel [X-Pos, Y-Pos, Laser-Blanking] im Speicher des Mikrocontrollers abgelegt und müssen über eine PC-Schnittstelle aktualisiert werden können.
3. Die Positionierung des Laserpunktes soll hinreichend "schnell" und "präzise" erfolgen so dass sich zumindest einfache geometrische Figuren auf einen weißen Hintergrund projizieren lassen.
4. Das System soll auf ein Computermodell abgebildet werden so dass unterschiedliche Regelalgorithmen evaluiert werden können. Außerdem sollen Hardware-Anpassungen der Signalkonditionierung (primär Antialiasing-/Rekonstruktionsfilter) mit minimalem Aufwand in die Simulation des Gesamtsystems einzupflegen sein.
5. Die Prototyp-Hardware soll bereits alle notwendigen Komponenten umfassen, die zur Messung weiterer Zustandsgrößen der Regelstrecke notwendig sind. Somit kann der Aufbau als Grundlage für spätere Tests einer Zustandsraum-Regelung (state space model) genutzt werden.
6. Die Anforderung an den Fertigungsprozess der Prototyp-Hardware sollte entsprechend den Möglichkeiten vor Ort (HsKA: PCB-Fräse, manuelle Durchkontaktierung bei doppelseitigen Layouts) angepasst werden.
</div>

</par>

Zu Beginn des Kapitels [Modellbildungsprozess](#modellbildungsprozess) folgt eine erste Aufteilung des Projekts.


<!-- wird $\vec v$ als  Richtungsvektor von $\vec{g}$.
Zur mathematischen Beschreibung dieser (abschnittsweise definierten) Geraden, kann aus zwei aufeinander folgenden XY-Tupel eine Geradengleichung abgeleitet werden. Um 

Aus der Koordinatenform einer Geradengleichung mit den Parametern  ${a}, {b}$ und ${c}$ ist ein Normalenvektor der Gerade direkt als $\vec n=(a,b)^{T}$ ablesbar und damit ein Richtungsvektor der Geraden analog zur Normalenform über   

$$ {\vec {u}}={\begin{pmatrix}-b\\\a\end{pmatrix}} $$ ermitteln. Einen Stützvektor der Geraden erhält man, je nachdem ob $a$ oder $b$ ungleich null ist, durch Wahl von
<center>$ {\vec {p}}={\begin{pmatrix}c/a\\\0\end{pmatrix}}\;\;\; $ oder $ \;\;\;{\vec {p}}={\begin{pmatrix}0\\\c/b\end{pmatrix}} $.</center> -->
